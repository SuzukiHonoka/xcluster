package user

import (
	"fmt"
	"xcluster/internal/database"
	"xcluster/pkg/argon2"
)

type User struct {
	ID       ID       `gorm:"type:uint;primaryKey;autoIncrement;unique"` // uid 0 is not allowed
	Name     Name     `gorm:"type:varchar(100);unique;not null"`         // account name
	Password Password `gorm:"type:varchar(255);not null"`                // argon2 hashed with salt
	Email    string   `gorm:"type:varchar(100);unique;not null"`
	Group    Group    `gorm:"type:uint;default:2"` // 0 -> baned, 1 -> admin, 2 -> user, ...
}

func NewUser(name, password, email string) (*User, error) {
	hash, err := argon2.NewArgon2(nil).GenerateHashFromString(password)
	if err != nil {
		return nil, err
	}
	user := &User{
		// note that ID is generated by database
		Name:     Name(name),
		Password: Password(hash.String()),
		Email:    email,
		Group:    1,
	}
	// add to database
	if err = database.DB.Create(&user).Error; err != nil {
		return nil, err
	}
	return user, nil
}

func GetAll() ([]*User, error) {
	var users []*User
	if err := database.DB.Find(&users).Error; err != nil {
		return nil, err
	}
	return users, nil
}

func (u *User) Update(name, password, email *string) error {
	val := map[string]interface{}{}
	switch {
	case name != nil:
		val["name"] = *name
	case password != nil:
		hash, err := argon2.NewArgon2(nil).GenerateHashFromString(*password)
		if err != nil {
			return err
		}
		val["password"] = hash
	case email != nil:
		val["email"] = *email
	}
	// optional: update receiver properties as well
	return database.DB.Model(u).Updates(val).Error
}

func (u *User) Delete() error {
	return u.ID.DeleteUser()
}

func (u *User) String() string {
	return fmt.Sprintf("[user] name=%s, email=%s", u.Name, u.Email)
}
